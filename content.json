{"meta":{"title":"smxknife's Blog","subtitle":"小人物，大梦想","description":"程序员成长笔记","author":"smxknife","url":"http://www.smxknife.com"},"pages":[{"title":"categories","date":"2017-03-18T16:02:27.000Z","updated":"2018-03-21T20:11:07.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.smxknife.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-18T16:02:27.000Z","updated":"2018-03-21T20:10:16.038Z","comments":false,"path":"tags/index.html","permalink":"http://www.smxknife.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git之暂存区","slug":"Git之暂存区","date":"2018-03-27T18:09:36.000Z","updated":"2018-03-27T18:11:09.000Z","comments":true,"path":"2018/03/28/Git之暂存区/","link":"","permalink":"http://www.smxknife.com/2018/03/28/Git之暂存区/","excerpt":"","text":"前篇之前提交过demo，如何查看日志呢 12345678910$ cd /git/test/demo$ git log --statcommit ac01ff39a78fa388e1e628754fd55a76feb358d2 (HEAD -&gt; master)Author: smxknife &lt;2323937771@qq.com&gt;Date: Tue Mar 27 23:38:05 2018 +0800 init hellogit file hellogit | 1 + 1 file changed, 1 insertion(+) 可以看到修改记录 diff现在对文件进行修改 $ echo &quot;new change&quot; &gt;&gt; hellogit 使用diff命令进行比较 12345678$ git diffdiff --git a/hellogit b/hellogitindex d974466..c49fee4 100644--- a/hellogit+++ b/hellogit@@ -1 +1,2 @@ Hello Git.+new change 从上面来看确实修改了，也存在差异，那么久提交吧 123456$ git commit -m \"modify hellofile, add new change\"On branch masterChanges not staged for commit: modified: hellogitno changes added to commit 从输出结果上看好像有点问题，貌似没提交成功，通过日志来看 12$ git log --pretty=onelineac01ff39a78fa388e1e628754fd55a76feb358d2 (HEAD -&gt; master) init hellogit file 日志里也只有一行输出，查看文件状态 $ git status或者$ git status -s（简略输出信息）输出如下： 12$ git status -s M hellogit 无论怎么看都是提交失败，什么原因？？？？这就涉及到了暂存区的概念 暂存区（stage）git规定修改文件之后要先执行add操作，虽然感觉很别扭，但是无奈只能这么做 $ git add hellogit 再用git diff会发现没有任何输出，再执行git status -s 12$ git status -sM hellogit 乍一看没什么变化，但是请与上面对比来看，是不是M的位置发生了变化，在add操作之前M的位置在第二列，add之后M的位置为第一列 第一列M代表的含义是：仓库中的文件与暂存区中的文件相比有改动第二列M代表的含义是：工作区中的当前文件与暂存区的文件相比有改动 那么执行add之前，M位于第二列，说明比较的是工作区与暂存区，而add之后比较的是仓库与暂存区 从这可以看出add的目的就是将工作区的文件提交到暂存区 那么再修改一下文件内容 1234567891011121314$ echo \"third change.\" &gt;&gt; hellogit $ git status -sMM hellogit$ git diffdiff --git a/hellogit b/hellogitindex c49fee4..990080f 100644--- a/hellogit+++ b/hellogit@@ -1,2 +1,3 @@ Hello Git. new change+third change. 从上面的结果来看，hellogit的status存在两个M，说明工作区相比暂存区有更改，暂存区相比仓库有更改。而此时git diff命令有输出结果了，说明git diff 默认是工作区与暂存区进行比较 从这个结果来看，文件在Git中会存在三种状态，仓库中的状态、暂存区中的状态、工作区中的当前状态 将工作区和HEAD（当前工作分支）相比 123456789$ git diff HEADdiff --git a/hellogit b/hellogitindex d974466..990080f 100644--- a/hellogit+++ b/hellogit@@ -1 +1,3 @@ Hello Git.+new change+third change. 将暂存区和仓库相比 （–cached或–staged） 1234567891011121314151617$ git diff --cacheddiff --git a/hellogit b/hellogitindex d974466..c49fee4 100644--- a/hellogit+++ b/hellogit@@ -1 +1,2 @@ Hello Git.+new change$ git diff --stageddiff --git a/hellogit b/hellogitindex d974466..c49fee4 100644--- a/hellogit+++ b/hellogit@@ -1 +1,2 @@ Hello Git.+new change 好了，现在进行commit操作，那么将会提交的是哪个版本呢？ 123$ git commit -m \"which version checked in?\"[master 0789463] which version checked in? 1 file changed, 1 insertion(+) 通过上面来看只有一行插入，所以两个变化只提交了一个 再通过一系列命令来查看 12345678910111213141516171819202122232425$ git status -s M hellogit$ git diffdiff --git a/hellogit b/hellogitindex c49fee4..990080f 100644--- a/hellogit+++ b/hellogit@@ -1,2 +1,3 @@ Hello Git. new change+third change.$ git diff HEADdiff --git a/hellogit b/hellogitindex c49fee4..990080f 100644--- a/hellogit+++ b/hellogit@@ -1,2 +1,3 @@ Hello Git. new change+third change.$ git diff --staged# 没有任何输出 通过上面一系列的输出来看，这次commit只提交了暂存区的文件修改，工作区的依然没有变化，所以，本地工作区每次修改文件后都需要先add到暂存区，然后再commit到仓库中。那么将所有的更改先提交到仓库吧 前面提到过.git/index文件，其实这个index就是暂存区文件，当执行git status扫描工作区改动的时候，先根据.git/index文件记录的时间戳、长度等信息判断工作区文件是否改变，如果工作区文件时间戳改变了，说明文件内容可能被改变了，需要打开文件读取内容，与原始文件进行比较，判断文件是否被改变。如果没有变化就将新的时间戳记录到.git/index文件中。通过时间戳和文件长度比较比文件内容比较快的多，这正是git高效的原因之一 通过下面的一张图来形象的理解一下工作区、暂存区、仓库（版本库）的原理 index其实就是一个索引目录树，记录了文件名和文件状态信息（时间戳和长度），真正的文件内容是存储在.git/objects目录中 $ git reset HEAD重写暂存区的目录树，此时会被master分支指向的目录树替换，但是不影响工作区 $ git rm --staged &lt;fileName&gt;会直接从暂存区删除文件，工作区不受影响 $ git checkout或$ git checkout -- &lt;fileName&gt; 这是两个非常危险的操作，前者会将暂存区所有的文件替换工作区的文件，后者是替换指定的文件。这两个操作都会导致工作区修改的且未添加的修改丢失，慎重！！！ $ git checkout HEAD或$ git checkout -- &lt;fileName&gt;这个与上面的类似，但是更加危险，会用仓库里面文件替换暂存区和工作区两个地方 一些命令查看HEAD指向的目录树git ls-tree -l HEAD 清理工作区突然发现工作区太乱了，没有有用的东西需要清理 12$ git clean -fd # 清楚工作区中没有加入仓库的文件和目录$ git checkout . # 使用暂存区进行刷新 查看暂存区的目录树git ls-files -s 不要使用git commit -aGit提供了一个简化命令，git commit -a 减少了add的步骤，可以直接将修改的文件进行commit，但是未被版本库跟踪的文件时不能提交的。 这样做确实简化了操作步骤，但是就会丢掉Git暂存区的最大好处：对提交的内容进行控制的能力","categories":[{"name":"git指南","slug":"git指南","permalink":"http://www.smxknife.com/categories/git指南/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.smxknife.com/tags/git/"}]},{"title":"Git之初始化","slug":"Git之初始化","date":"2018-03-27T16:02:28.000Z","updated":"2018-03-27T16:33:31.605Z","comments":true,"path":"2018/03/28/Git之初始化/","link":"","permalink":"http://www.smxknife.com/2018/03/28/Git之初始化/","excerpt":"","text":"前言本文是对《Git权威指南》的简单记录，如果看过原著可以绕过 PS：包括后面的Git之系列的文章都可以绕道而行 版本git --version用来查询当前机器上的git的版本号 配置变量git的配置变量是一次性工作，这些设置会在全局文件（用户目录下的.gitconfig）或系统文件（如/etc/gitconfig）中记录 用户名和邮件$ git config --global user.name &quot;smxknife&quot;$ git config --global user.email smxknife@qq.com 上面两条命令分别用来配置当前用户的姓名和邮件地址，这将会在版本库提交时用到 别名设置别名是为了命令操作更爽，试想一下，输入git ci爽还是输入git commit爽，（注：如果使用的是系统管理员，那么设置的别名可以被所有人员使用） 1234$ sudo git config --system alias.st status$ sudo git config --system alias.ci commit$ sudo git config --system alias.co checkout$ sudo git config --system alias.br branch 也可以通过以下方式，只设置当前用户的全局方式 1234$ git config --global alias.st status$ git config --global alias.ci commit$ git config --global alias.co checkout$ git config --global alias.br branch 命令行颜色设置$ git config --global color.ui true 初始化git初始化命令非常简单git init $ cd /git/test $ git init demo 这样初始化已经做好了，在demo下会有一个.git文件，这个隐藏的.git就是Git的仓库，而/git/test/demo被称为工作区 提交内容新建一个测试文件 12$ cd /git/test/demo/$ echo \"Hello Git.\" &gt; hellogit 将hellogit添加到仓库 12$ git add hellogit # 此时并没有提交，这与svn是一样的，需要执行下一步commit才算提交$ git commit -m \"init hellogit file\" 执行完毕之后会得到以下输出 123[master (root-commit) ac01ff3] init hellogit file 1 file changed, 1 insertion(+) create mode 100644 hellogit 从结果上看提交到master分支上，第一个提交为root-commit，提交ID为ac01ff3，第二行此次修改了一个文件，包含了一行插入第三行此次提交创建了新文件 hellogit .gitgit提供了一个非常方便的命令用来进行搜索 $ git grep &quot;文件内容搜索&quot; 如 12$ git grep \"Hello\"hellogit:Hello Git. .git/index文件记录工作区文件的状态（实际上是暂存区的状态） git命令是在工作区工作的，如果在工作区的子目录下，git会一直递归查找.git目录，如果所有的目录中递归无法找到，将会报错。那么如何定位.git的工作区的根目录呢？ $ git rev-parse --git-dir 显示工作区根目录 $ git rev-parse --show-toplevel 相对工作区根目录的相对目录 $ git rev-parse --show-prefix 显示档期目录后退到工作区根目录的深度 $ git rev-parse --show-cdup","categories":[{"name":"git指南","slug":"git指南","permalink":"http://www.smxknife.com/categories/git指南/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.smxknife.com/tags/git/"}]},{"title":"Java拆箱/装箱原理","slug":"Java拆箱-装箱原理","date":"2018-03-21T20:25:04.000Z","updated":"2018-03-21T20:25:57.000Z","comments":true,"path":"2018/03/22/Java拆箱-装箱原理/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Java拆箱-装箱原理/","excerpt":"","text":"java中原始数据类型byte =&gt; Byte short =&gt; Short chart =&gt; Character int =&gt; Integer float =&gt; Float long =&gt; Long double =&gt; Double boolean =&gt; Boolean 什么是自动拆箱、装箱自动装箱就是自动将原始数据类型转换为对应的对象类型（编译器编译时调用valueOf将原始类型转换为对象）自动拆箱就是自动将对象类型转换为原始数据类型（编译器编译时调用类似于intValue()、doubleValue()方法将对象转换为原始值） 1234// 自动装箱Integer i = 1;// 自动拆箱int j = i; 自动拆箱、装箱的时机赋值时1234// 自动装箱Integer i = 1;// 自动拆箱int j = i; 方法调用传值时1234public void test(Integer i) &#123; ...&#125;test(1); 自动拆箱、装箱的弊端自动拆箱、装箱看似简单方便（用着也确实方便），但是却隐藏着一些弊端 影响性能在数据量小的时候可能没有太大的影响，但是随着数据量的增多就会额外的创建许多无意义的对象，以及数据转换的过程 1234Integer sum = 0；for(int i = 0; i &lt; 100000; i++) &#123; sum += i;&#125; 因为sum是Integer对象，不支持 += 操作，所以循环中会进行类似如下的自动的拆箱再装箱的过程： 12sum = sum.intValue() + i;sum = Integer.valueOf(sum); NullPointerException12Integer a = null;int b = a; 上面的代码就会抛出空指针异常 == 判断问题（缓存问题）这个在之前的文章中有介绍《Long == Long 有趣的现象》 重载与自动拆箱、装箱当重载遇上自动装箱时，情况会比较有些复杂，可能会让人产生有些困惑。在1.5之前，value(int)和value(Integer)是完全不相同的方法，开发者不会因为传入是int还是Integer调用哪个方法困惑，但是由于自动装箱和拆箱的引入，处理重载方法时稍微有点复杂。一个典型的例子就是ArrayList的remove方法，它有remove(index)和remove(Object)两种重载，我们可能会有一点小小的困惑，其实这种困惑是可以验证并解开的，当出现这种情况时，不会发生自动装箱操作。 1234567891011// demo1public static void test1(int i) &#123; System.out.println(\"int\");&#125;public static void test1(Integer i) &#123; System.out.println(\"integer\");&#125;test1(1);test1(Integer.valueOf(1)); 输出结果为： int integer // demo2 public static void test1(int i) { System.out.println(\"int\"); } //public static void test1(Integer i) { // System.out.println(\"integer\"); //} test1(1); test1(Integer.valueOf(1)); 输出结果为： int int","categories":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/tags/java/"},{"name":"自动拆箱","slug":"自动拆箱","permalink":"http://www.smxknife.com/tags/自动拆箱/"}]},{"title":"Java序列化","slug":"Java序列化","date":"2018-03-21T20:24:25.000Z","updated":"2018-03-21T20:24:46.062Z","comments":true,"path":"2018/03/22/Java序列化/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Java序列化/","excerpt":"","text":"序列化就是将对象表示为一个字节序列，包括了该对象的数据，有关对象的类型信息和存储在对象中数据的类型。 序列化对象写入文件之后，可以从文件中读取出来，并进行反序列化，在内存中新建对象。 ObjectInputStream和ObjectOutputStreamjava中序列化和反序列化的关键的两个方类是ObjectInputStream和ObjectOutputStream类 123// ObjectOutputStream提供了一个序列化对象，并输出到流的方法public final void writeObject(Object x) throws IOException 123// ObjectInputStream提供了一个从流中读取对象，并反序列化的方法public final Object readObject() throws IOException, ClassNotFoundException 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Employee implements Serializable &#123; private static final long serialVersionUID = 1L; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + name + \" \" + address); &#125;&#125;public class SerializeDemo &#123; public static void main(String[] args) &#123; Employee e = new Employee(); e.name = \"test\"; e.address = \"hangzhou\"; e.SSN = 12345678; e.number = 110; try &#123; FileOutputStream fos = new FileOutputStream(\"./employee.ser\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(e); oos.close(); fos.close(); System.out.println(\"saved\"); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125;public class DeserializeDemo &#123; public static void main(String[] args) &#123; Employee e = null; try &#123; FileInputStream fis = new FileInputStream(\"./employee.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); e = (Employee) ois.readObject(); ois.close(); fis.close(); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; catch (ClassNotFoundException e1) &#123; System.out.println(\"employee class not found\"); e1.printStackTrace(); &#125; System.out.println(\"Deserialized Employee...\"); System.out.println(\"Name: \" + e.name); System.out.println(\"Address: \" + e.address); System.out.println(\"SSN: \" + e.SSN); System.out.println(\"Number: \" + e.number); &#125;&#125;// 输出结果Deserialized Employee...Name: testAddress: hangzhouSSN: 0Number: 110 深入思考上面就是序列化的一个简单例子，但是还有一些细节仍然需要注意 序列号问题如果Employee中不显式的写序列号，那么会很容易出现各种莫名其妙的问题，序列号是编译器生成的，所以如果当对象序列化完成之后，突然改了一点对象的内容，重新编译后，没有再次重新的序列化直接就反序列化，这时候肯定会出错，因为序列号变了，序列号其实就相当于版本控制，改变的对象之后，版本号肯定要发生变化，所以有时为了避免该问题，最好手动添加序列号 静态属性序列化对Employee对象进行修改，增加一个静态属性在实例化之后，更改静态属性的值，再反序列化，输出静态属性的值，得到的却是更改后的值。 这里面的原因其实显而易见，序列化是对对象进行实例化，而static是类的属性，所以不会对静态成员进行序列化，读取该对象的值，获取的是类的属性值。因此 序列化并不保存静态属性。 父类序列化如果子类实现了Serializable接口，父类没有实现Serializable接口，那么将子类进行序列化之后，反序列化之后获取的值，父类的属性值全部变为成员变量对应类型的默认值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Animal &#123; public String name; public int type;&#125;public class Cat extends Animal implements Serializable &#123; public String color;&#125;public class ExtendsSerDeserDemo &#123; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.name = \"bosi\"; cat.type = 0; cat.color = \"yellow\"; try &#123; FileOutputStream fos = new FileOutputStream(\"./cat.ser\"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(cat); oos.close(); fos.close(); System.out.println(\"saved\"); FileInputStream fis = new FileInputStream(\"./cat.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); Cat cat1 = (Cat) ois.readObject(); ois.close(); fis.close(); System.out.println(cat1.name); System.out.println(cat1.type); System.out.println(cat1.color); &#125; catch (FileNotFoundException e1) &#123; e1.printStackTrace(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 输出结果null0yellow 还有一个需要注意的地方就是，如果没有实现Serializable接口，那么父类必须含有无惨的构造函数，否则在反序列化时会报错 上面有这么多问题，其实解决方法很简单，将父类也实现Serializable接口即可 Transient关键字该关键字的使用方法在上面已经有出现过，Employee里面的SSN属性，使用方法就是在属性前加上transient即可，这样就可以阻止该属性被序列化。在反序列化时会将该属性的值直接设置为初始值 虚拟机调用在序列化过程中，虚拟机会试图调用对象里面的writeObject和readObject方法，进行用户自定义的序列化和反序列化。如果没有，则默认调用ObjectInputStream里面的defaultReadObject和ObjectOutputStream里面的defaultWriteObject方法 123456789101112131415161718192021222324252627282930313233343536public class Cat extends Animal implements Serializable &#123; public String color; public Cat() &#123; super(1); &#125; private void writeObject(ObjectOutputStream out) &#123; try &#123; ObjectOutputStream.PutField putField = out.putFields(); System.out.println(\"原始颜色： \" + color); color = \"加密了\"; System.out.println(\"加密后的颜色： \" + color); putField.put(\"color\", color); out.writeFields(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void readObject(ObjectInputStream in) &#123; try &#123; ObjectInputStream.GetField getField = in.readFields(); Object color = getField.get(\"color\", \"\"); System.out.println(\"解密前的颜色： \" + color); color = \"yellow\"; System.out.println(\"解密后的颜色： \" + color); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/tags/java/"},{"name":"序列化","slug":"序列化","permalink":"http://www.smxknife.com/tags/序列化/"}]},{"title":"Java奇数特性","slug":"Java奇数特性","date":"2018-03-21T20:23:30.000Z","updated":"2018-03-21T20:24:05.401Z","comments":true,"path":"2018/03/22/Java奇数特性/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Java奇数特性/","excerpt":"","text":"在某些时候，出于某些目的可能会要求进行一些奇数性的判断，如果你是newer，很有可能因为经验的不足造成一些在后期让人难以发现的的bug。 如何进行奇数判断有可能你会这么写 123public static boolean isOdd(int i) &#123; return i % 2 == 1;&#125; 也有可能你会这么写 123public static boolean isOdd(int i) &#123; return i % 2 != 0;&#125; 如果你选择了第一种的写法，那么恭喜你，你中标了，在未来的某些时候bug会找到你，而用第二种的就没有问题。 现在还没发现问题的人，那么你可能是忽略了负数的情况，-1 % 2 等于 -1而不是1 运行下面代码就能发现问题： 1234567891011121314151617181920212223242526272829303132333435public class OddDemo2 &#123; public static void main(String[] args) &#123; for (int i = -10; i &lt; 10; i++) &#123; mod2(i); &#125; &#125; public static void mod2(int i) &#123; System.out.println(i + \" % 2 = \" + (i % 2)); &#125;&#125;// 结果输出：-10 % 2 = 0-9 % 2 = -1-8 % 2 = 0-7 % 2 = -1-6 % 2 = 0-5 % 2 = -1-4 % 2 = 0-3 % 2 = -1-2 % 2 = 0-1 % 2 = -10 % 2 = 01 % 2 = 12 % 2 = 03 % 2 = 14 % 2 = 05 % 2 = 16 % 2 = 07 % 2 = 18 % 2 = 09 % 2 = 1 位运算判断法到目前为止，已经可以解决奇数性的问题，这完全是个经验问题，那么下面再介绍一种性能更高一点的，更加高大上的一种判断方法：位运算法 代码如下： 123public static boolean isOdd2(int i) &#123; return (i &amp; 2) == 1;&#125; 是否看起来很简单，但是对于不熟悉位运算的人来说看着你很牛掰😂 位运算判断法解析“&amp;”对于java开发者来说，你可以不熟悉，但是你不可以做到不知道，这是什么，运算规则是什么 &amp; 按位与，将数字转化为二进制之后，只有两个操作数对应位同为1时，结果为1，其余全为0 这里就需要引入原码，反码，补码三个概念，简单介绍： 正数的原码、反码、补码是一样的 负数的反码等于原码的符号位不变，其余位按位取反，补码等于反码加一 对于位运算不熟悉的猿友来说，需要稍微注意的一点是，计算机中都是采用补码来进行计算 开始解析，以3和-3为例 [1]原 = [1]反 = [1]补 = 00000000 00000000 00000000 00000001 [3]原 = [3]反 = [3]补 = 00000000 00000000 00000000 00000011 [-3]原 = 10000000 00000000 00000000 00000011[-3]反 = 11111111 11111111 11111111 11111100[-3]补 = 11111111 11111111 11111111 11111101 1 &amp; 3 结果为 00000000 00000000 00000000 00000001，很明显为1 1 &amp; -3 结果计算稍微复杂一点，上面说了用补码进行运算，所以补码运算结果为00000000 00000000 00000000 00000001 结果依然为1 很明显通过这种方式就屏蔽了正负数的原因造成的bug，还获得了更高的性能。","categories":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/tags/java/"}]},{"title":"SpringBoot之配置文件优先级","slug":"SpringBoot之配置文件优先级","date":"2018-03-21T20:22:30.000Z","updated":"2018-03-21T20:22:51.166Z","comments":true,"path":"2018/03/22/SpringBoot之配置文件优先级/","link":"","permalink":"http://www.smxknife.com/2018/03/22/SpringBoot之配置文件优先级/","excerpt":"","text":"简介application.properties和application.yml 这是常用的配置文件命名，大家应该都很熟悉。但是它们的优先级到底哪个更高呢？下面就开始做试验。都以server.port来测试 properties vs yml- resources - application.properties # 8081 - application.yml # 8082 通过简单的启动试验发现 properties &gt; yml classpath: vs classpath:/config- resources - application.properties # 8081 - /config/application.properties # 8082 启动发现 classpath:/config &gt; classpath classpath:/config/yml vs classpath:properties通过上面发现properties的优先级大于yml，config的优先级大于classpath，那么config下面的yml与classpath下面的properties对比如何呢？ - resources - application.properties # 8081 - /config/application.yml # 8082 启动发现 classpath:/config/yml &gt; classpath:properties通过这个试验可以发现，位置的优先级大于命名的优先级 properties vs -profile.propertiesapplication.properties 与 application-{profile}.properties 默认的profile为default，那么久先对比application.properties 与 applicaation-default.properties 的优先级 - resources - application.properties # 8081 - application-default.properties # 8082 启动发现，application-default.properties &gt; application.properties properties vs -profile.yml与上面的试验类似，将application-default.properties替换为application-default.yml - resources - application.properties # 8081 - application-default.yml # 8082 启动发现，application-default.yml &gt; application.properties所以，加上-default的profile属性时，yml将会大于不加profile的properties，当然如果同时加上profile的属性，那么properties依然会大于yml classpath:/config/properties vs classpath:application-default.yml通过前面的实验发现config的优先级还是蛮高的，但是与default相比谁高呢？ - resources - application-default.yml # 8081 - /config/application.properties # 8082 启动发现，application-default.yml &gt; /config/application.properties。default的优先级是大于config目录的 classpath:/config/application-default.yml vs classpath:/application-default.yml- resources - application-default.yml # 8081 - /config/application-default.yml # 8082 启动发现，同样是default的条件下，config/application-default.yml &gt; application-default.yml 总结config/application-default.properties &gt; config/application-default.yml &gt; application-default.properties &gt; application-default.yml &gt; config/application.properties &gt; config/application.yml &gt; application.properties &gt; application.yml","categories":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/tags/springboot/"}]},{"title":"SpringBoot之SpringApplication","slug":"SpringBoot之SpringApplication","date":"2018-03-21T20:21:47.000Z","updated":"2018-03-21T20:22:08.573Z","comments":true,"path":"2018/03/22/SpringBoot之SpringApplication/","link":"","permalink":"http://www.smxknife.com/2018/03/22/SpringBoot之SpringApplication/","excerpt":"","text":"简介可以用于从java主方法中引导和启动Spring应用程序的类，在默认情况下，通过以下步骤来启动应用： 创建一个ApplicationContext实例 注册CommandLinePropertySource用来暴露命令行参数作为spring的属性 refresh applicationContext，加载所有的singleton bean 触发任何CommandLineRunner bean 自定义SpringApplication默认的启动方式，代码如下，不做深入介绍 1SpringApplication.run(AppBoot1.class, args); 当然也可以做一些定制，如在Banner里面介绍的自定义banner，还有添加Listener等诸多设置，格式如下： 123SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); 使用Fluent Builder API进行构建先上代码，如下： 12345678910111213141516171819202122232425262728293031new SpringApplicationBuilder() .sources(ParentConfig.class) .child(Child1Config.class) .sibling(Child2Config.class) .banner(new AppBanner()) .logStartupInfo(false) .run(args); // ParentConfig.class//@Configuration@SpringBootApplication@PropertySource(\"classpath:/parent.properties\")public class ParentConfig &#123;&#125;// Child1Config.class@SpringBootApplication@PropertySource(\"classpath:/child1.properties\")public class Child1Config &#123;&#125;// Child2Config.class@SpringBootApplication@PropertySource(\"classpath:/child2.properties\")public class Child2Config &#123;&#125; 使用SpringApplicationBuilder在构建分层的ApplicationContext应用的时候非常便利，但是官网给的代码示例很简单，对于一些初次介入的人可能理解上不是那么透彻。就上面的代码做一些简单的介绍 .sources(ParentConfig.class)该方法是用来配置父配置，或主配置的。但是有坑!!!!请看上面的ParentConfig的代码，注解我使用的是@SpringBootApplication，如果你使用的是springboot的1.x的版本，那么你会很顺利，如果你正在研究springboot 2.x的版本，你会发现无论如何也无法启动成功（我被坑的好惨）…。聪明的人也许看到我的注释，没错换成@Configuration之后就可以正常工作。但是很抱歉，这是为什么暂时还没找到原因，在github上请教暂时也没得到正确的结果，后面继续研究，如果有人发现了其中的原因，请通知我一下 .child(Child1Config.class)那么通过名字就可以看到是子环境了，Child1Config就是child1的配置文件。也许你的应用里有多个child，那么你可能会想用多个child().child()，那么这样你的第二个child不是parent的child，而是第一个child的child，parent的孙子。想要实现多个同级的孩子，可以使用代码中的.sibling(Child2Config.class)方法。这里同样存在一个springboot的版本改动问题，那就是如果你要在配置文件里面为child1配置一个context path，那么在版本1里面的方法是server.contextPath=child1，但是如果使用版本2的朋友就需要做一点小改动了，改为server.servlet.contextPath=child1 可以参照github上的代码进行详细的理解github 事件和监听器spring里面的监听器有三种实现方式： @EventListener注解方式 实现ApplicationListener接口 实现SmartApplicationListener接口 上面三种方式代码分别为 12345678910@Componentpublic class AnnotationRegisterListener &#123; @EventListener public void register(UserRegisterEvent event) &#123; User user = event.getUser(); System.out.println(\"AnnotationRegisterListener \" + user.getName() + \", \" + user.getPassword()); &#125;&#125; 1234567891011@Componentpublic class RegisterListener implements ApplicationListener&lt;UserRegisterEvent&gt;&#123; @Override public void onApplicationEvent(UserRegisterEvent event) &#123; User user = event.getUser(); System.out.println(\"RegisterListener \" + user.getName() + \", \" + user.getPassword()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class UserRegisterListener implements SmartApplicationListener &#123; /** * 该方法返回true&amp;supportsSourceType同样返回true时，才会调用该监听内的onApplicationEvent方法 * @param eventType * @return */ @Override public boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType) &#123; return UserRegisterEvent.class.isAssignableFrom(eventType); &#125; /** * 该方法返回true&amp;supportsEventType同样返回true时，才会调用该监听内的onApplicationEvent方法 * @param sourceType * @return */ @Override public boolean supportsSourceType(@Nullable Class&lt;?&gt; sourceType) &#123; return UserService.class.isAssignableFrom(sourceType); &#125; @Override public void onApplicationEvent(ApplicationEvent event) &#123; UserRegisterEvent userRegisterEvent = (UserRegisterEvent) event; User user = userRegisterEvent.getUser(); System.out.println(\"UserRegisterListener \" + user.getName() + \", \" + user.getPassword()); &#125; /** * 同步情况下监听执行的顺序 * @return */ @Override public int getOrder() &#123; return 3; &#125;&#125; 前两种实现方式比较简单，稍微介绍一下第三种，这种实现方式必须在supportsEventType和supportsSourceType同时返回true的情况下才会执行事件，具体如何返回true和false就看你自己的业务实现。在这里我使用了jdk的isAssignableFrom方法来判断父子关系的。上面两种方式事件的执行顺序是无序的，第三种提供了一种指定属性的方法getOrder() 具体的isAssignableFrom是如何使用的，请看如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Animal &#123;&#125;public class Bird extends Animal implements Fly &#123;&#125;public class Dove extends Bird &#123;&#125;public class Penguin extends Bird &#123;&#125;public interface Fly &#123;&#125;public class Demo03 &#123; public static void main(String[] args) &#123; assignOut(Animal.class, Animal.class); assignOut(Animal.class, Bird.class); assignOut(Bird.class, Animal.class); assignOut(Animal.class, Dove.class); assignOut(Penguin.class, Dove.class); assignOut(Fly.class, Bird.class); assignOut(Fly.class, Dove.class); &#125; static void assignOut(Class cls1, Class cls2) &#123; System.out.println(cls1.getSimpleName() + \" isAssignableFrom \" + cls2.getSimpleName() + \" : \" + cls1.isAssignableFrom(cls2)); &#125;&#125;// 输出结果Animal isAssignableFrom Animal : trueAnimal isAssignableFrom Bird : trueBird isAssignableFrom Animal : falseAnimal isAssignableFrom Dove : truePenguin isAssignableFrom Dove : falseFly isAssignableFrom Bird : trueFly isAssignableFrom Dove : true SpringBoot启动过程中的事件及监听器 ApplicationStartingEvent 应用开始启动时执行，在初始化listeners and initializers之前执行 ApplicationEnvironmentPreparedEvent 环境准备好开始执行，上下文创建之前执行 ApplicationPreparedEvent 应用准备好开始执行，即所有bean都已经加载完毕之后，在refresh方法执行之前执行 ApplicationStartedEvent 应用启动后开始执行，即上下文被refreshed之后，任何的application和command-line runners调用前执行 ApplicationReadyEvent 应用启动完毕开始执行，任何的application和command-line runners调用后执行，从此后可以服务request了 ApplicationFailedEvent 启动时遇到异常执行 Listener的写法很简单，只以ApplicationStartingEvent为例，其他类似 123456789101112131415161718public class MyApplicationStartedListener implements ApplicationListener&lt;ApplicationStartedEvent&gt; &#123; @Override public void onApplicationEvent(ApplicationStartedEvent applicationStartedEvent) &#123; System.out.println(\"MyApplicationStartedListener...\"); &#125;&#125;在main方法注入SpringApplicationBuilder builder = new SpringApplicationBuilder(); builder.listeners(new MyApplicationStartingListener()); builder.listeners(new MyApplicationEnvironmentPreparedListener()); builder.listeners(new MyApplicationPreparedListener()); builder.listeners(new MyApplicationStartedListener());// builder.listeners(new MyApplicationReadyListener()); builder.sources(AppBoot.class); builder.run(args);或者可以在META-INF/spring.factories中配置org.springframework.context.ApplicationListener=com.smxknife.springboot.v2.ex03.listener.MyApplicationReadyListener 看一下输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041422018-03-03 01:24:06.387 INFO 5399 --- [ restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged2018-03-03 01:28:58.909 INFO 5399 --- [ Thread-28] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@58c49e73: startup date [Sat Mar 03 01:24:05 CST 2018]; root of context hierarchy2018-03-03 01:28:58.913 INFO 5399 --- [ Thread-28] o.s.j.e.a.AnnotationMBeanExporter : Unregistering JMX-exposed beans on shutdownMyApplicationStartingListener...MyApplicationEnvironmentPreparedListener... . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.0.RC2)2018-03-03 01:28:59.534 INFO 5399 --- [ restartedMain] com.smxknife.springboot.v2.ex03.AppBoot : Starting AppBoot on ShaoYundeMacBook-Pro.local with PID 5399 (/Users/ShaoYun/local/workstation/programs/smxknife/spring-boot/spring-boot-v2/spring-boot-v2-web/target/classes started by ShaoYun in /Users/ShaoYun/local/workstation/programs/smxknife/spring-boot)2018-03-03 01:28:59.536 INFO 5399 --- [ restartedMain] com.smxknife.springboot.v2.ex03.AppBoot : No active profile set, falling back to default profiles: defaultMyApplicationPreparedListener...2018-03-03 01:28:59.539 INFO 5399 --- [ restartedMain] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@45b78eb1: startup date [Sat Mar 03 01:28:59 CST 2018]; root of context hierarchy2018-03-03 01:29:00.304 INFO 5399 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 10101 (http)2018-03-03 01:29:00.305 INFO 5399 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service [Tomcat]2018-03-03 01:29:00.305 INFO 5399 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.282018-03-03 01:29:00.316 INFO 5399 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2018-03-03 01:29:00.317 INFO 5399 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 778 ms2018-03-03 01:29:00.338 INFO 5399 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Servlet dispatcherServlet mapped to [/]2018-03-03 01:29:00.338 INFO 5399 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'characterEncodingFilter' to: [/*]2018-03-03 01:29:00.338 INFO 5399 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]2018-03-03 01:29:00.338 INFO 5399 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'httpPutFormContentFilter' to: [/*]2018-03-03 01:29:00.338 INFO 5399 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: 'requestContextFilter' to: [/*]2018-03-03 01:29:00.492 INFO 5399 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@45b78eb1: startup date [Sat Mar 03 01:28:59 CST 2018]; root of context hierarchy2018-03-03 01:29:00.529 INFO 5399 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/register]&#125;\" onto public java.lang.String com.smxknife.springboot.v2.ex03.web.controller.UserController.register(com.smxknife.springboot.v2.ex03.domain.User)2018-03-03 01:29:00.533 INFO 5399 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error]&#125;\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2018-03-03 01:29:00.534 INFO 5399 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"&#123;[/error],produces=[text/html]&#125;\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2018-03-03 01:29:00.555 INFO 5399 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-03-03 01:29:00.555 INFO 5399 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-03-03 01:29:00.591 INFO 5399 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-03-03 01:29:00.648 INFO 5399 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292018-03-03 01:29:00.720 INFO 5399 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2018-03-03 01:29:00.738 INFO 5399 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 10101 (http) with context path ''2018-03-03 01:29:00.739 INFO 5399 --- [ restartedMain] com.smxknife.springboot.v2.ex03.AppBoot : Started AppBoot in 1.585 seconds (JVM running for 3711.163)MyApplicationStartedListener...MyApplicationReadyListener...2018-03-03 01:29:00.741 INFO 5399 --- [ restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged Listener的相关代码可以参照 github","categories":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/tags/springboot/"}]},{"title":"SpringBoot之Banner","slug":"SpringBoot之Banner","date":"2018-03-21T20:20:49.000Z","updated":"2018-03-21T20:21:20.239Z","comments":true,"path":"2018/03/22/SpringBoot之Banner/","link":"","permalink":"http://www.smxknife.com/2018/03/22/SpringBoot之Banner/","excerpt":"","text":"1234567 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.0.BUILD-SNAPSHOT) 熟悉的banner，这是springboot的默认banner，对于项目来说有可以，没有也可以，也可以自己定制，权当无聊玩玩~ 自定义banner官方提供了以下解决方案： 通过banner.txt来自定义 通过添加图片banner.gif，banner.jpg, banner.png 编程的方式SpringApplication.setBanner(…​) banner.txt 将该文件放在类路径下即可（可以直接放在/resource/下面），也可以通过配置文件的spring.banner.location属性来进行定位 如果文件编码不是utf8，可以通过spring.banner.charset进行自定义设置 springboot为我们提供了banner参数的占位符 ${application.version} 应用版本号 ${application.formatted-version} 格式化应用版本号，如（v1.0） ${spring-boot.version} springboot的版本号 ${spring-boot.formatted-version} ${Ansi.NAME} (or ${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME}) ${application.title} 也许你按照上面的格式写了，但是最后的输出结果，很有可能只输出了springboot的版本号，这是正常的，其他的都需要有条件输出，具体的参考官网 图片 就是要做一张图片同样放到类路径下即可，同样可以通过spring.banner.image.location来进行定位 必须是banner.gif，banner.jpg, banner.png这三个名称 编程的方式可以新建一个类实现Banner接口，也可以使用匿名类 1234567891011121314public class AppBanner implements Banner &#123; public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; out.append(\"================================\\r\\n\") .append(\"------ \") .append(environment.getProperty(\"app.name\") + \"\\r\\n\") .append(sourceClass.getName() + \"\\r\\n\") .append(\"================================\").println(); &#125;&#125;// main函数SpringApplication app = new SpringApplication(ApplicationBoot.class); app.setBanner(new AppBanner()); app.run(args); 1234567SpringApplication app = new SpringApplication(ApplicationBoot.class); app.setBanner(new Banner() &#123; public void printBanner(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123; // TODO &#125; &#125;); app.run(args); 匿名类与实现类同样都是实现printBanner方法，该方法的三个参数 environment 环境变量，可以获取properties或者yml中的key-value值 sourceClass 就是SpringApplication配置的class，这里就是ApplicationBoot.class out 就是负责的输出流 PS：这里需要注意一点，在main函数中的写法，上面的main写法是可行的， 但是如果改为下面的写法将不会输出，或者就会变成默认输出 123SpringApplication app = new SpringApplication(); app.setBanner(new AppBanner()); app.run(ApplicationBoot.class, args); 优先级这么多的定义方式，如果我全部定义了，该显示哪个呢？ 首先，图片的优先级最高，如果与banner.txt同时存在会优先显示图片，然后再显示banner.txt。注意，这两个是可以同时显示的 而图片存在三种格式，优先级从高到低为 .gif &gt; .jpg &gt; .png，这三种如果同时存在会安装优先级的顺序显示优先级最高的一张图片，其余的忽略不显示 编程的方式是优先级最弱的，只有在上面两种同时不存在的情况下才会生效 其他设置 关闭banner：有时如果觉得麻烦，又不喜欢spring的logo，那么直接关掉就可以啦 SpringApplication.setBannerMode(Banner.Mode.OFF); spring.main.banner-model=off 这里还有一个需要注意的地方就是，如果采用的是.yml的配置文件，直接这样写启动会失败，这可能是yml的问题，需要将off改为’off’即可 Banner.Mode的模式 CONSOLE 默认模式，输出到控制台 LOG 在log中显示 OFF 关闭banner 如果同时存在代码设置开启，配置设置关闭两种方式哪种会生效呢？配置的优先级 &gt; 编程，所以…","categories":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/categories/springboot/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://www.smxknife.com/tags/springboot/"}]},{"title":"Spring之scope解惑","slug":"Spring之scope解惑","date":"2018-03-21T20:19:47.000Z","updated":"2018-03-21T20:20:13.000Z","comments":true,"path":"2018/03/22/Spring之scope解惑/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Spring之scope解惑/","excerpt":"","text":"Spring的作用域scope在2.0之前只有两种singleton和prototype（网上说的，没去验证，那时候还没仔细研究过…），后面增加了session、request、global session三种专门用于web应用程序上下文的Bean Singleton这是spring的bean的默认的作用域-单例。但是此单例又与设计模式中的单例模式不一样，设计模式的单例在设计模式的文章中再介绍。 singleton不要简单的理解为全局只有一个，真正的意义是在一个上下文（ApplicationContext）中只有一个。如果在一个项目中有多个ApplicationContext，那么获取的Bean对象就不只一个了 在同一个容器或上下文中，所有对单例bean的请求，只要id与该bean定义相匹配，都会返回同一个实例。简单说就是bean定义为singleton时，ioc容器只会创建该bean的唯一实例，然后存储在单例缓存（singleton cache）中。 singleton的bean是无状态的，只有一份，所以无论哪个线程获取的都是同一个同样的实例，具有线程无关性。Spring使用ThreadLocal解决线程安全问题，这就要求在使用singleton的bean时不能存在属性的改变，如果存在属性改变，就需要慎重使用，采用同步来处理多线程问题，或者考虑使用prototype作用域。 基于上面，我们常用的Controller、Service、Repository、Configuration这些bean基本上都是项目启动就已经初始化完毕，每个bean的属性都已经确定，在运行过程中也不会更改，这样就很适合单例模式。这里再说一下实体类（用@Entity注解修饰的）这个可不是一个bean，试想一下，每次使用实体的时候是不是都是DomainA a = new DomainA();，应该没有人这么用private DomainA domianA;```1234567使用scope的方法如下：```java@Scope(&quot;singleton&quot;)@Componentpublic class MainService &#123;...&#125; Prototype相对应singleton，prototype就属于多例模式，每次请求都会创建一个新的实例，相当于new操作。 对于prototype类型的bean，spring只负责创建初始化，不会对整个生命周期负责，随后的所有操作都交给客户端来处理 现在问一个问题，如何声明一个prototype的bean并使用呢？（先不要急着往下看，想一下，就以在ScopeTestController里面注入prototype的PrototypeService来说明） ~ ~ ~ ~ 思考中... ~ ~ ~ ~ 可能很多人（包括我）开始会以为像以下这种写法就可以 123456789101112131415161718192021public interface PrototypeService &#123;&#125;@Service@Scope(\"prototype\")public class PrototypeServiceImpl implements PrototypeService &#123;&#125;@RestControllerpublic class ScopeTestController &#123; @Autowired PrototypeService prototypeService; @GetMapping(\"/\") public void testPrototype() &#123; System.out.println(prototypeService); &#125;&#125; 启动项目，两次次请求，查看控制台输出 com.ukirin.idle.web.service.impl.PrototypeServiceImpl@74738f89 com.ukirin.idle.web.service.impl.PrototypeServiceImpl@74738f89 ？一样？什么情况？其实仔细想一下也就明白了错在哪，Controller是一个单例，在启动时就已经把Service注入了，所以不可能改变，当然现在你可以这么改，将Controller同样改为prototype的。那么恭喜你回答正确，但是，这不是我们的目的，我们的目的是要看在单例中如何使用。 方法1：从ApplicationContext里面获取将Controller里面的代码做以下改动 12345678910111213141516@RestControllerpublic class ScopeTestController &#123;// @Autowired// PrototypeService prototypeService; @Autowired WebApplicationContext applicationContext; @GetMapping(\"/\") public void testPrototype() &#123;// System.out.println(prototypeService); System.out.println(applicationContext.getBean(PrototypeService.class)); &#125;&#125; 这样每次都从上下文中请求一个实例，容器对每个请求都实例化一个新的Service，没有问题 方法2：方法1的变种，采用工厂模式来生成Service代码就不写了… 方法3：使用代理很简单，在@Scope里面加上代理模式即可 12345678910111213141516171819202122@Service@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.INTERFACES)public class PrototypeServiceImpl implements PrototypeService &#123;&#125;@RestControllerpublic class ScopeTestController &#123; @Autowired PrototypeService prototypeService;// @Autowired// WebApplicationContext applicationContext; @GetMapping(\"/\") public void testPrototype() &#123; System.out.println(prototypeService);// System.out.println(applicationContext.getBean(PrototypeService.class)); &#125;&#125; 这样，就可以每次获取不同的Service了，这个的原理就是，在初始化Controller的时候并不是讲一个Service的实体注入，而是注入一个代理，当真正调用Service的时候，代理会对其进行依赖解析，并调用真正的实体bean 额外需要注意的一点是，如果注入的不是接口的实现，而是一个类，那么需要将proxyMode = ScopedProxyMode.INTERFACES改为proxyMode = ScopedProxyMode.TARGET_CLASS request该作用域将 bean 的定义限制为 HTTP 请求。只在 web-aware Spring ApplicationContext 的上下文中有效 上述的实验结果是每次请求都会输出不一样的结果，在这里可能会与prototype产生困惑，做以下的实验可以解决你的困惑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface PrototypeService &#123;&#125;@Service@Scope(value = \"request\", proxyMode = ScopedProxyMode.INTERFACES)public class PrototypeServiceImpl implements PrototypeService &#123;&#125;public interface MiddleService &#123; void test();&#125;@Servicepublic class MiddleServiceImpl implements MiddleService &#123; @Autowired PrototypeService prototypeService; @Override public void test() &#123; System.out.println(\"middle : \" + prototypeService); &#125;&#125;@RestControllerpublic class ScopeTestController &#123; @Autowired MiddleService middleService; @Autowired PrototypeService prototypeService;// @Autowired// WebApplicationContext applicationContext; @GetMapping(\"/\") public void testPrototype() &#123; System.out.println(\"controller : \" + prototypeService);// System.out.println(applicationContext.getBean(PrototypeService.class)); middleService.test(); &#125;&#125; 输出结果为： controller : com.ukirin.idle.web.service.impl.PrototypeServiceImpl@6b90371c middle : com.ukirin.idle.web.service.impl.PrototypeServiceImpl@6b90371c 然后将作用域改为prototype再测试一下输出结果为： controller : com.ukirin.idle.web.service.impl.PrototypeServiceImpl@49b2c498 middle : com.ukirin.idle.web.service.impl.PrototypeServiceImpl@ccb8c47 结果显而易见 session该作用域将 bean 的定义限制为 HTTP 会话。 只在web-aware Spring ApplicationContext的上下文中有效。 上述的实验结果是一个会话内输出结果是一样的 global-session该作用域将 bean 的定义限制为全局 HTTP 会话。只在 web-aware Spring ApplicationContext 的上下文中有效。","categories":[{"name":"spring","slug":"spring","permalink":"http://www.smxknife.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.smxknife.com/tags/spring/"}]},{"title":"Long==Long有趣的现象","slug":"Long-Long有趣的现象","date":"2018-03-21T20:18:25.000Z","updated":"2018-03-21T20:18:56.933Z","comments":true,"path":"2018/03/22/Long-Long有趣的现象/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Long-Long有趣的现象/","excerpt":"","text":"1. 描述首先，这里应该声明一下，Long等对象类型判断是否相等，采用Long == Long这种形式是错误的。 可以采用以下方式： 12345678Long left = 100L;Long right = 100L;// 方法1：System.out.println(left.doubleValue() == right.doubleValue());// 方法2：System.out.println(left.compareTo(right)); 输出结果： 12true0 1.1 实验1如果你亲自操刀，动手做了以下实验，也许你会突然得到一个让你困惑的结果： 1234Long left = 100L;Long right = 100L;System.out.println(left == right); 输出结果： 1true 没错，采用 == 竟然也能得出true，也许这时候你可能会误以为jvm在自动拆箱（我以前也是这样以为，有点小白！！！）。 1.2 实验2那么请你再做下面这个实验： 1234567891011Long left = 1000L;Long right = 1000L;// 方法1：System.out.println(left.doubleValue() == right.doubleValue());// 方法2：System.out.println(left.compareTo(right));// 错误的方法：System.out.println(left == right); 输出结果 123true0false 等会，什么情况，怎么又为false？ 1.3 实验3不急，再做一个实验。 1234567for (int i = -200; i &lt; 200; i++) &#123; Long left = Long.valueOf(i); Long right = Long.valueOf(i); System.out.println(\"Long left = \" + i + \", Long right = \" + i + \", left == right :\" + (left == right)); &#125; 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400Long left = -200, Long right = -200, left == right :falseLong left = -199, Long right = -199, left == right :falseLong left = -198, Long right = -198, left == right :falseLong left = -197, Long right = -197, left == right :falseLong left = -196, Long right = -196, left == right :falseLong left = -195, Long right = -195, left == right :falseLong left = -194, Long right = -194, left == right :falseLong left = -193, Long right = -193, left == right :falseLong left = -192, Long right = -192, left == right :falseLong left = -191, Long right = -191, left == right :falseLong left = -190, Long right = -190, left == right :falseLong left = -189, Long right = -189, left == right :falseLong left = -188, Long right = -188, left == right :falseLong left = -187, Long right = -187, left == right :falseLong left = -186, Long right = -186, left == right :falseLong left = -185, Long right = -185, left == right :falseLong left = -184, Long right = -184, left == right :falseLong left = -183, Long right = -183, left == right :falseLong left = -182, Long right = -182, left == right :falseLong left = -181, Long right = -181, left == right :falseLong left = -180, Long right = -180, left == right :falseLong left = -179, Long right = -179, left == right :falseLong left = -178, Long right = -178, left == right :falseLong left = -177, Long right = -177, left == right :falseLong left = -176, Long right = -176, left == right :falseLong left = -175, Long right = -175, left == right :falseLong left = -174, Long right = -174, left == right :falseLong left = -173, Long right = -173, left == right :falseLong left = -172, Long right = -172, left == right :falseLong left = -171, Long right = -171, left == right :falseLong left = -170, Long right = -170, left == right :falseLong left = -169, Long right = -169, left == right :falseLong left = -168, Long right = -168, left == right :falseLong left = -167, Long right = -167, left == right :falseLong left = -166, Long right = -166, left == right :falseLong left = -165, Long right = -165, left == right :falseLong left = -164, Long right = -164, left == right :falseLong left = -163, Long right = -163, left == right :falseLong left = -162, Long right = -162, left == right :falseLong left = -161, Long right = -161, left == right :falseLong left = -160, Long right = -160, left == right :falseLong left = -159, Long right = -159, left == right :falseLong left = -158, Long right = -158, left == right :falseLong left = -157, Long right = -157, left == right :falseLong left = -156, Long right = -156, left == right :falseLong left = -155, Long right = -155, left == right :falseLong left = -154, Long right = -154, left == right :falseLong left = -153, Long right = -153, left == right :falseLong left = -152, Long right = -152, left == right :falseLong left = -151, Long right = -151, left == right :falseLong left = -150, Long right = -150, left == right :falseLong left = -149, Long right = -149, left == right :falseLong left = -148, Long right = -148, left == right :falseLong left = -147, Long right = -147, left == right :falseLong left = -146, Long right = -146, left == right :falseLong left = -145, Long right = -145, left == right :falseLong left = -144, Long right = -144, left == right :falseLong left = -143, Long right = -143, left == right :falseLong left = -142, Long right = -142, left == right :falseLong left = -141, Long right = -141, left == right :falseLong left = -140, Long right = -140, left == right :falseLong left = -139, Long right = -139, left == right :falseLong left = -138, Long right = -138, left == right :falseLong left = -137, Long right = -137, left == right :falseLong left = -136, Long right = -136, left == right :falseLong left = -135, Long right = -135, left == right :falseLong left = -134, Long right = -134, left == right :falseLong left = -133, Long right = -133, left == right :falseLong left = -132, Long right = -132, left == right :falseLong left = -131, Long right = -131, left == right :falseLong left = -130, Long right = -130, left == right :falseLong left = -129, Long right = -129, left == right :falseLong left = -128, Long right = -128, left == right :trueLong left = -127, Long right = -127, left == right :trueLong left = -126, Long right = -126, left == right :trueLong left = -125, Long right = -125, left == right :trueLong left = -124, Long right = -124, left == right :trueLong left = -123, Long right = -123, left == right :trueLong left = -122, Long right = -122, left == right :trueLong left = -121, Long right = -121, left == right :trueLong left = -120, Long right = -120, left == right :trueLong left = -119, Long right = -119, left == right :trueLong left = -118, Long right = -118, left == right :trueLong left = -117, Long right = -117, left == right :trueLong left = -116, Long right = -116, left == right :trueLong left = -115, Long right = -115, left == right :trueLong left = -114, Long right = -114, left == right :trueLong left = -113, Long right = -113, left == right :trueLong left = -112, Long right = -112, left == right :trueLong left = -111, Long right = -111, left == right :trueLong left = -110, Long right = -110, left == right :trueLong left = -109, Long right = -109, left == right :trueLong left = -108, Long right = -108, left == right :trueLong left = -107, Long right = -107, left == right :trueLong left = -106, Long right = -106, left == right :trueLong left = -105, Long right = -105, left == right :trueLong left = -104, Long right = -104, left == right :trueLong left = -103, Long right = -103, left == right :trueLong left = -102, Long right = -102, left == right :trueLong left = -101, Long right = -101, left == right :trueLong left = -100, Long right = -100, left == right :trueLong left = -99, Long right = -99, left == right :trueLong left = -98, Long right = -98, left == right :trueLong left = -97, Long right = -97, left == right :trueLong left = -96, Long right = -96, left == right :trueLong left = -95, Long right = -95, left == right :trueLong left = -94, Long right = -94, left == right :trueLong left = -93, Long right = -93, left == right :trueLong left = -92, Long right = -92, left == right :trueLong left = -91, Long right = -91, left == right :trueLong left = -90, Long right = -90, left == right :trueLong left = -89, Long right = -89, left == right :trueLong left = -88, Long right = -88, left == right :trueLong left = -87, Long right = -87, left == right :trueLong left = -86, Long right = -86, left == right :trueLong left = -85, Long right = -85, left == right :trueLong left = -84, Long right = -84, left == right :trueLong left = -83, Long right = -83, left == right :trueLong left = -82, Long right = -82, left == right :trueLong left = -81, Long right = -81, left == right :trueLong left = -80, Long right = -80, left == right :trueLong left = -79, Long right = -79, left == right :trueLong left = -78, Long right = -78, left == right :trueLong left = -77, Long right = -77, left == right :trueLong left = -76, Long right = -76, left == right :trueLong left = -75, Long right = -75, left == right :trueLong left = -74, Long right = -74, left == right :trueLong left = -73, Long right = -73, left == right :trueLong left = -72, Long right = -72, left == right :trueLong left = -71, Long right = -71, left == right :trueLong left = -70, Long right = -70, left == right :trueLong left = -69, Long right = -69, left == right :trueLong left = -68, Long right = -68, left == right :trueLong left = -67, Long right = -67, left == right :trueLong left = -66, Long right = -66, left == right :trueLong left = -65, Long right = -65, left == right :trueLong left = -64, Long right = -64, left == right :trueLong left = -63, Long right = -63, left == right :trueLong left = -62, Long right = -62, left == right :trueLong left = -61, Long right = -61, left == right :trueLong left = -60, Long right = -60, left == right :trueLong left = -59, Long right = -59, left == right :trueLong left = -58, Long right = -58, left == right :trueLong left = -57, Long right = -57, left == right :trueLong left = -56, Long right = -56, left == right :trueLong left = -55, Long right = -55, left == right :trueLong left = -54, Long right = -54, left == right :trueLong left = -53, Long right = -53, left == right :trueLong left = -52, Long right = -52, left == right :trueLong left = -51, Long right = -51, left == right :trueLong left = -50, Long right = -50, left == right :trueLong left = -49, Long right = -49, left == right :trueLong left = -48, Long right = -48, left == right :trueLong left = -47, Long right = -47, left == right :trueLong left = -46, Long right = -46, left == right :trueLong left = -45, Long right = -45, left == right :trueLong left = -44, Long right = -44, left == right :trueLong left = -43, Long right = -43, left == right :trueLong left = -42, Long right = -42, left == right :trueLong left = -41, Long right = -41, left == right :trueLong left = -40, Long right = -40, left == right :trueLong left = -39, Long right = -39, left == right :trueLong left = -38, Long right = -38, left == right :trueLong left = -37, Long right = -37, left == right :trueLong left = -36, Long right = -36, left == right :trueLong left = -35, Long right = -35, left == right :trueLong left = -34, Long right = -34, left == right :trueLong left = -33, Long right = -33, left == right :trueLong left = -32, Long right = -32, left == right :trueLong left = -31, Long right = -31, left == right :trueLong left = -30, Long right = -30, left == right :trueLong left = -29, Long right = -29, left == right :trueLong left = -28, Long right = -28, left == right :trueLong left = -27, Long right = -27, left == right :trueLong left = -26, Long right = -26, left == right :trueLong left = -25, Long right = -25, left == right :trueLong left = -24, Long right = -24, left == right :trueLong left = -23, Long right = -23, left == right :trueLong left = -22, Long right = -22, left == right :trueLong left = -21, Long right = -21, left == right :trueLong left = -20, Long right = -20, left == right :trueLong left = -19, Long right = -19, left == right :trueLong left = -18, Long right = -18, left == right :trueLong left = -17, Long right = -17, left == right :trueLong left = -16, Long right = -16, left == right :trueLong left = -15, Long right = -15, left == right :trueLong left = -14, Long right = -14, left == right :trueLong left = -13, Long right = -13, left == right :trueLong left = -12, Long right = -12, left == right :trueLong left = -11, Long right = -11, left == right :trueLong left = -10, Long right = -10, left == right :trueLong left = -9, Long right = -9, left == right :trueLong left = -8, Long right = -8, left == right :trueLong left = -7, Long right = -7, left == right :trueLong left = -6, Long right = -6, left == right :trueLong left = -5, Long right = -5, left == right :trueLong left = -4, Long right = -4, left == right :trueLong left = -3, Long right = -3, left == right :trueLong left = -2, Long right = -2, left == right :trueLong left = -1, Long right = -1, left == right :trueLong left = 0, Long right = 0, left == right :trueLong left = 1, Long right = 1, left == right :trueLong left = 2, Long right = 2, left == right :trueLong left = 3, Long right = 3, left == right :trueLong left = 4, Long right = 4, left == right :trueLong left = 5, Long right = 5, left == right :trueLong left = 6, Long right = 6, left == right :trueLong left = 7, Long right = 7, left == right :trueLong left = 8, Long right = 8, left == right :trueLong left = 9, Long right = 9, left == right :trueLong left = 10, Long right = 10, left == right :trueLong left = 11, Long right = 11, left == right :trueLong left = 12, Long right = 12, left == right :trueLong left = 13, Long right = 13, left == right :trueLong left = 14, Long right = 14, left == right :trueLong left = 15, Long right = 15, left == right :trueLong left = 16, Long right = 16, left == right :trueLong left = 17, Long right = 17, left == right :trueLong left = 18, Long right = 18, left == right :trueLong left = 19, Long right = 19, left == right :trueLong left = 20, Long right = 20, left == right :trueLong left = 21, Long right = 21, left == right :trueLong left = 22, Long right = 22, left == right :trueLong left = 23, Long right = 23, left == right :trueLong left = 24, Long right = 24, left == right :trueLong left = 25, Long right = 25, left == right :trueLong left = 26, Long right = 26, left == right :trueLong left = 27, Long right = 27, left == right :trueLong left = 28, Long right = 28, left == right :trueLong left = 29, Long right = 29, left == right :trueLong left = 30, Long right = 30, left == right :trueLong left = 31, Long right = 31, left == right :trueLong left = 32, Long right = 32, left == right :trueLong left = 33, Long right = 33, left == right :trueLong left = 34, Long right = 34, left == right :trueLong left = 35, Long right = 35, left == right :trueLong left = 36, Long right = 36, left == right :trueLong left = 37, Long right = 37, left == right :trueLong left = 38, Long right = 38, left == right :trueLong left = 39, Long right = 39, left == right :trueLong left = 40, Long right = 40, left == right :trueLong left = 41, Long right = 41, left == right :trueLong left = 42, Long right = 42, left == right :trueLong left = 43, Long right = 43, left == right :trueLong left = 44, Long right = 44, left == right :trueLong left = 45, Long right = 45, left == right :trueLong left = 46, Long right = 46, left == right :trueLong left = 47, Long right = 47, left == right :trueLong left = 48, Long right = 48, left == right :trueLong left = 49, Long right = 49, left == right :trueLong left = 50, Long right = 50, left == right :trueLong left = 51, Long right = 51, left == right :trueLong left = 52, Long right = 52, left == right :trueLong left = 53, Long right = 53, left == right :trueLong left = 54, Long right = 54, left == right :trueLong left = 55, Long right = 55, left == right :trueLong left = 56, Long right = 56, left == right :trueLong left = 57, Long right = 57, left == right :trueLong left = 58, Long right = 58, left == right :trueLong left = 59, Long right = 59, left == right :trueLong left = 60, Long right = 60, left == right :trueLong left = 61, Long right = 61, left == right :trueLong left = 62, Long right = 62, left == right :trueLong left = 63, Long right = 63, left == right :trueLong left = 64, Long right = 64, left == right :trueLong left = 65, Long right = 65, left == right :trueLong left = 66, Long right = 66, left == right :trueLong left = 67, Long right = 67, left == right :trueLong left = 68, Long right = 68, left == right :trueLong left = 69, Long right = 69, left == right :trueLong left = 70, Long right = 70, left == right :trueLong left = 71, Long right = 71, left == right :trueLong left = 72, Long right = 72, left == right :trueLong left = 73, Long right = 73, left == right :trueLong left = 74, Long right = 74, left == right :trueLong left = 75, Long right = 75, left == right :trueLong left = 76, Long right = 76, left == right :trueLong left = 77, Long right = 77, left == right :trueLong left = 78, Long right = 78, left == right :trueLong left = 79, Long right = 79, left == right :trueLong left = 80, Long right = 80, left == right :trueLong left = 81, Long right = 81, left == right :trueLong left = 82, Long right = 82, left == right :trueLong left = 83, Long right = 83, left == right :trueLong left = 84, Long right = 84, left == right :trueLong left = 85, Long right = 85, left == right :trueLong left = 86, Long right = 86, left == right :trueLong left = 87, Long right = 87, left == right :trueLong left = 88, Long right = 88, left == right :trueLong left = 89, Long right = 89, left == right :trueLong left = 90, Long right = 90, left == right :trueLong left = 91, Long right = 91, left == right :trueLong left = 92, Long right = 92, left == right :trueLong left = 93, Long right = 93, left == right :trueLong left = 94, Long right = 94, left == right :trueLong left = 95, Long right = 95, left == right :trueLong left = 96, Long right = 96, left == right :trueLong left = 97, Long right = 97, left == right :trueLong left = 98, Long right = 98, left == right :trueLong left = 99, Long right = 99, left == right :trueLong left = 100, Long right = 100, left == right :trueLong left = 101, Long right = 101, left == right :trueLong left = 102, Long right = 102, left == right :trueLong left = 103, Long right = 103, left == right :trueLong left = 104, Long right = 104, left == right :trueLong left = 105, Long right = 105, left == right :trueLong left = 106, Long right = 106, left == right :trueLong left = 107, Long right = 107, left == right :trueLong left = 108, Long right = 108, left == right :trueLong left = 109, Long right = 109, left == right :trueLong left = 110, Long right = 110, left == right :trueLong left = 111, Long right = 111, left == right :trueLong left = 112, Long right = 112, left == right :trueLong left = 113, Long right = 113, left == right :trueLong left = 114, Long right = 114, left == right :trueLong left = 115, Long right = 115, left == right :trueLong left = 116, Long right = 116, left == right :trueLong left = 117, Long right = 117, left == right :trueLong left = 118, Long right = 118, left == right :trueLong left = 119, Long right = 119, left == right :trueLong left = 120, Long right = 120, left == right :trueLong left = 121, Long right = 121, left == right :trueLong left = 122, Long right = 122, left == right :trueLong left = 123, Long right = 123, left == right :trueLong left = 124, Long right = 124, left == right :trueLong left = 125, Long right = 125, left == right :trueLong left = 126, Long right = 126, left == right :trueLong left = 127, Long right = 127, left == right :trueLong left = 128, Long right = 128, left == right :falseLong left = 129, Long right = 129, left == right :falseLong left = 130, Long right = 130, left == right :falseLong left = 131, Long right = 131, left == right :falseLong left = 132, Long right = 132, left == right :falseLong left = 133, Long right = 133, left == right :falseLong left = 134, Long right = 134, left == right :falseLong left = 135, Long right = 135, left == right :falseLong left = 136, Long right = 136, left == right :falseLong left = 137, Long right = 137, left == right :falseLong left = 138, Long right = 138, left == right :falseLong left = 139, Long right = 139, left == right :falseLong left = 140, Long right = 140, left == right :falseLong left = 141, Long right = 141, left == right :falseLong left = 142, Long right = 142, left == right :falseLong left = 143, Long right = 143, left == right :falseLong left = 144, Long right = 144, left == right :falseLong left = 145, Long right = 145, left == right :falseLong left = 146, Long right = 146, left == right :falseLong left = 147, Long right = 147, left == right :falseLong left = 148, Long right = 148, left == right :falseLong left = 149, Long right = 149, left == right :falseLong left = 150, Long right = 150, left == right :falseLong left = 151, Long right = 151, left == right :falseLong left = 152, Long right = 152, left == right :falseLong left = 153, Long right = 153, left == right :falseLong left = 154, Long right = 154, left == right :falseLong left = 155, Long right = 155, left == right :falseLong left = 156, Long right = 156, left == right :falseLong left = 157, Long right = 157, left == right :falseLong left = 158, Long right = 158, left == right :falseLong left = 159, Long right = 159, left == right :falseLong left = 160, Long right = 160, left == right :falseLong left = 161, Long right = 161, left == right :falseLong left = 162, Long right = 162, left == right :falseLong left = 163, Long right = 163, left == right :falseLong left = 164, Long right = 164, left == right :falseLong left = 165, Long right = 165, left == right :falseLong left = 166, Long right = 166, left == right :falseLong left = 167, Long right = 167, left == right :falseLong left = 168, Long right = 168, left == right :falseLong left = 169, Long right = 169, left == right :falseLong left = 170, Long right = 170, left == right :falseLong left = 171, Long right = 171, left == right :falseLong left = 172, Long right = 172, left == right :falseLong left = 173, Long right = 173, left == right :falseLong left = 174, Long right = 174, left == right :falseLong left = 175, Long right = 175, left == right :falseLong left = 176, Long right = 176, left == right :falseLong left = 177, Long right = 177, left == right :falseLong left = 178, Long right = 178, left == right :falseLong left = 179, Long right = 179, left == right :falseLong left = 180, Long right = 180, left == right :falseLong left = 181, Long right = 181, left == right :falseLong left = 182, Long right = 182, left == right :falseLong left = 183, Long right = 183, left == right :falseLong left = 184, Long right = 184, left == right :falseLong left = 185, Long right = 185, left == right :falseLong left = 186, Long right = 186, left == right :falseLong left = 187, Long right = 187, left == right :falseLong left = 188, Long right = 188, left == right :falseLong left = 189, Long right = 189, left == right :falseLong left = 190, Long right = 190, left == right :falseLong left = 191, Long right = 191, left == right :falseLong left = 192, Long right = 192, left == right :falseLong left = 193, Long right = 193, left == right :falseLong left = 194, Long right = 194, left == right :falseLong left = 195, Long right = 195, left == right :falseLong left = 196, Long right = 196, left == right :falseLong left = 197, Long right = 197, left == right :falseLong left = 198, Long right = 198, left == right :falseLong left = 199, Long right = 199, left == right :false 通过这个超长的输出结果，你会发现，存在一个区间[-128, 127]，在这个区间里通过 == 这种方式返回的是true ，其他返回的都是false。 2. 总结其实，通过源码分析： 1234567public static Long valueOf(long l) &#123; final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) &#123; // will cache return LongCache.cache[(int)l + offset]; &#125; return new Long(l); &#125; 在128~127这些数的对象在内存中被缓存起来，在内存中提供重用，这些数获取的时候就会自动获取缓存中的数，而不是new出来的对象。所以，这与自动打包拆包无关。 再所以…，判读Long对象是否相等的时候建议不要采用 == 的形式，程序中无法绝对的判断参数值是否会在这个区间内，如果不在，那就出现让你摸不着头脑的问题。","categories":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/tags/java/"}]},{"title":"Spring_Transaction使用","slug":"Spring-Transaction使用","date":"2018-03-21T20:13:29.000Z","updated":"2018-03-21T20:14:59.000Z","comments":true,"path":"2018/03/22/Spring-Transaction使用/","link":"","permalink":"http://www.smxknife.com/2018/03/22/Spring-Transaction使用/","excerpt":"","text":"注解@Transactional注意常用的该注解有两个，一个是java本身的，一个是spring的org.springframework.transaction.annotation.Transactionaljavax.transaction.Transactional这两个在使用上基本没什么区别，只是属性名称稍有不同其中，rollback的默认类为RuntimeException和Error，隔离级别默认为数据源的隔离级别，传播行为默认为REQUIRE下面以spring的注解使用为例 在service的实现类的方法上使用demo11234public User createUser(User user) &#123; userRepository.save(user); throw new RuntimeException();&#125; demo212345@Transactional(rollbackOn = Exception.class)public User createUser(User user) &#123; userRepository.save(user); throw new RuntimeException();&#125; demo312345@Transactionalpublic User createUser(User user) &#123; userRepository.save(user); throw new RuntimeException();&#125; demo412345@Transactionalpublic User createUser(User user) throws Exception &#123; userRepository.save(user); throw new Excepton();&#125; ps:这里要注意的是Exception异常的分类，运行时异常（RuntimeException/未检查异常） 和非运行时异常（非RuntimeException/已检查异常），所有的RuntimeException可以不 需要捕获异常，默认的在throws里面已经处理，而非RuntimeException都需要，通过try catch 或者 throws 来手动处理捕获 demo5@Transactional(rollbackOn = Exception.class) public User createUser(User user) throws Exception { userRepository.save(user); throw new Exception(); } 运行结果数据不会因为异常而插入数据库的demo有：demo1和demo4，其他所有的的都会因为异常而发生事务的回滚操作 其中， demo1：因为没有使用事务，所有在save方法完成之后直接commit事务，正常提交demo2：回滚的异常设置为Exception，而RuntimeException是Exception的子类，所有发生异常事务回滚demo3：采用默认的设置，@Transactional默认的设置为RuntimeException和Error，这两者及其子类，那么在发生RuntimeException异常时，事务发生回滚demo4：采用默认的设置，但是抛出的异常时Exception，无法被事务捕获，所以无法让事务回滚demo5：手动设置回滚的异常为Exception，那么发生所有的Exception或者子异常，都会触发回滚操作 事务无法生效的解决思路 首先要确认数据库和表的存储引擎是否是InnoDB，如果是MyISAM是不支持事务的 如果事务加在Service接口的方法上，那么要确定，实现类是否是通过java动态代理进行实例化的，如果不是通过代理，那么事务也不会执行，因为cglib是不用实现接口的 事务的异常处理是否合理，具体的思路参考上面 还有一点需要注意，在spring中定义的事务的方法是否是public类型","categories":[{"name":"spring","slug":"spring","permalink":"http://www.smxknife.com/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.smxknife.com/tags/spring/"},{"name":"事务","slug":"事务","permalink":"http://www.smxknife.com/tags/事务/"}]},{"title":"java动态代理，不一样的理解方式","slug":"java动态代理，不一样的理解方式","date":"2018-03-21T20:05:46.000Z","updated":"2018-03-21T20:06:54.000Z","comments":true,"path":"2018/03/22/java动态代理，不一样的理解方式/","link":"","permalink":"http://www.smxknife.com/2018/03/22/java动态代理，不一样的理解方式/","excerpt":"","text":"简介我所理解的动态代理，最后的运行方式其实是一个静态代理加上一些反射机制，请注意，我说的是最后的运行方式 静态代理抛开动态代理先不说，先看一下什么是静态代理，明白了静态代理，那么动态代理最后是如何运行的读完本篇文章基本上也就明白了 123456789101112131415161718192021222324252627282930313233public interface Service &#123; public void doSomething(String context);&#125;public class ServiceImpl implements Service &#123; @Override public void doSomething(String context) &#123; System.out.println(\"do \" + context); &#125;&#125;public class StaticProxy &#123; private Service service; public StaticProxy(Service service) &#123; this.service = service; &#125; public void doSomething(String content) &#123; System.out.println(\"do pre\"); service.doSomething(content); System.out.println(\"do post\"); &#125;&#125;public class StaticMain &#123; public static void main(String[] args) &#123; StaticProxy proxy = new StaticProxy(new ServiceImpl()); proxy.doSomething(\"coding\"); &#125;&#125; 这就是一个简单的静态代理的例子，把ServiceImpl的执行交给了StaticProxy来执行，在执行的前后可以添加do pre和do post的业务逻辑。StaticProxy会在编译期就被编译成一个class文件被加载（这与动态代理有很大的区别） 动态代理再来看动态代理，先不说动态代理的实现过程，上面说到是否编译成class文件是静态代理与动态代理的一个很大的区别。那这就表明，动态代理是没有class文件的，那它是怎么实现的呢？其实，我个人理解动态代理之所以叫做动态的，就是这个生成的过程是不定的。在运行时生成一份代理类的字节码并加载到jvm中。 先来看一下最后生成的字节码类，就以上面的类型为例 123456789101112public final class $Proxy1 extends Proxy implements Service &#123; private InvocationHandler h; // 这是java提供的一个接口 private $Proxy1() &#123;&#125; private $Proxy1(InvocationHandler h) &#123; this.h = h; &#125; public void doSomething(String content) &#123; Method method = Service.class.getMethod(\"doSomething\", new Class[]&#123;String.class&#125;); return h.invoke(this, method, new Object[]&#123;new String(content)&#125;); &#125;&#125; 看一下$Proxy1这个类与上面的StaticProxy的结构是不是类似， 都实现了Service 都是将接口的实现注入到构造函数中，为接口提供具体的实现类 最后都调用doSomething来调用具体的业务，只不过在动态代理里面通过反射来调用 看完$Proxy1，个人感觉就是一个静态代理的一个变种，把这个结果看明白了，那后面其实都是一些模板代码，目的就是为了生成这个类 有人会问$Proxy1，为什么会叫这个名字，我只能说我不知道，jvm就是这么做的，以\\$开头，以数字标号来结尾。我现在不关心，我很开心我揭开动态代理的一层神秘的面纱，至少，不再像以前那样让人感觉高不可攀了（其实，还有很多层没揭开） 那下面就来看一下那些模板代码把 123456789101112131415161718192021222324252627282930313233343536373839public interface Service &#123; public void doSomething(String context);&#125;public class ServiceImpl implements Service &#123; @Override public void doSomething(String context) &#123; System.out.println(\"do \" + context); &#125;&#125;public class ServiceInvocationHandler implements InvocationHandler &#123; private Object object; public ServiceInvocationHandler(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"do pre\"); method.invoke(object, args); System.out.println(\"do post\"); return null; &#125;&#125;public class DynamicMain &#123; public static void main(String[] args) &#123; Service service = new ServiceImpl(); ServiceInvocationHandler handler = new ServiceInvocationHandler(service); Service proxyService = (Service) Proxy.newProxyInstance(handler.getClass().getClassLoader(), service.getClass().getInterfaces(), handler); proxyService.doSomething(\"coding\"); &#125;&#125; Service与ServiceImpl与静态代理没什么区别，将静态代理的代理类换成了InvocationHandler处理器的实现类。再有就是调用方式变了一下。 这里从main函数开始看，先指定Service的实现类，并构造Handler实现类。下面是重点，就是下面这行代码，用来生成$Proxy1这个字节码类的 Proxy的newProxyInstance方法，首先传递一个classloader，用这个classloader来加载生成的字节码类到jvm中；第二个参数是ServiceImpl实现的接口（即Service），使生成的字节码类也实现这个接口；第三个参数就是这个自定义的Handler了，将自定义的ServiceInvocationHandler传递给了$Proxy1中的InvocationHandler接口。 proxyService.doSomething，其实就是调用的$Proxy1的doSomething方法，然后再调用invoke方法。 怎么样，现在是不是已经对动态代理的理解又加深了一步呢！！！🙂","categories":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.smxknife.com/tags/java/"},{"name":"动态代理","slug":"动态代理","permalink":"http://www.smxknife.com/tags/动态代理/"}]}]}